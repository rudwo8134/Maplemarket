'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = __importDefault(require("path"));
var context_1 = __importDefault(require("./context"));
/**
 * This is a class that decides which command to run based on provided arguments. It parses the <code>process.argv</code> array and
 * executes a command or throws an error. It's main methods are: <br>
 * <ul>
 *  <li> <code>parse()</code> </li>
 *  <li> <code>executeCommand()</code> </li>
 * </ul>
 */
var CommandInvoker = /** @class */ (function () {
    function CommandInvoker() {
        this.entity = '';
        this.command = '';
        this.args = [];
        this.flags = [];
        /**
         * A collection of valid entities that can be provided as the first argument of the mdb command.
         *
         * @type {Set<string>}
         * @private
         */
        this._validEntities = new Set([
            'app', 'backend', 'blank', 'database', 'frontend', 'order', 'repo', 'starter', 'user', 'wordpress'
        ]);
        /**
         * A collection of valid commands that do not require an entity to be provided. It's the case when we make the
         *
         * <pre> $ mdb <command> </pre>
         *
         * call. The entity will be guessed based on the command used.
         *
         * @type {Set<string>}
         * @private
         */
        this._validNonEntityCommands = new Set([
            'help', 'update', 'version', 'register', 'login', 'logout', 'ls', 'init', 'get', 'rename', 'publish', 'delete', 'whoami', 'logs', 'kill', 'info', 'restart', 'run', 'config', 'status'
        ]);
        /**
         * A collection of valid flags that do not require neither an entity nor a command to be provided. It's the case when we make the
         *
         * <pre> $ mdb <flag> </pre>
         *
         * call. The entity and command will be guessed based on the flag used.
         *
         * @type {Set<string>}
         * @private
         */
        this._validFlagOnlyCommands = new Set([
            '-h', '--help',
            '-v', '--version'
        ]);
        /**
         * A collection of valid commands that are aliases to some other entity-command pair.
         *
         * @type {Set<string>}
         * @private
         */
        this._validAliasCommands = new Set([
            'starters', 'orders'
        ]);
        /**
         * An array of arguments (entity, command, args, flags) passed to the <code> mdb </code> command.
         *
         * @type {string[]}
         */
        this.argv = [];
    }
    /**
     * A method that does the main job which is parsing the arguments and selecting the proper entity, command, args and flags.
     *
     * Now, the command usage is as follows: <br>
     *
     *     <pre> mdb &lt;entity&gt; &lt;command&gt; [args] [flags] </pre>
     *
     * and the parsing logic goes like this (in <string>that</strong> order):
     *
     * <ol>
     *     <li> If the first argument is an entity, then the next argument must be a command. Then, all of the arguments until the first flag are args. The rest are flags. </li>
     *     <li> If the first argument is a non-entity command, then obviously it's a command. The entity is selected based on the entity-command mapping which is defined in the <code>_getDefaultEntityForCommand()</code> method and is just hardcoded. Again, all of the arguments until the first flag are args. The rest are flags. </li>
     *     <li> If the first argument is an alias, then resolve alias and select an entity-command pair. Again, this is hardcoded in the <code>_resolveAlias()</code> method. Again, all of the arguments until the first flag are args. The rest are flags. </li>
     *     <li> If the first argument is a flag-only command, then select the command using the <code>_getDefaultCommandForFlag()</code> method with hardcoded mapping. Based on that command, select the entity (from hardcoded mapping in <code>_getDefaultEntityForCommand()</code> method). Again, all of the arguments until the first flag are args. The rest are flags. </li>
     *     <li> If the first argument is not any of the above, throw an error </li>
     * </ol>
     *
     * @param {string[]} processArgv An array of arguments passed to the <code> mdb </code> command. It's <code> process.argv </code>
     * @throws If the first argument cannot be classified as an entity, a non-entity command, an alias or a flag-only command, throw an <code>Invalid command: mdb &lt;command&gt;</code> error.
     */
    CommandInvoker.prototype.parse = function (processArgv) {
        var _a, _b, _c, _d;
        var _this = this;
        this.argv = processArgv.slice(2);
        var firstArg = this._consumeNext();
        if (this._isEntity(firstArg)) {
            this.entity = firstArg;
            this.command = this._consumeNext();
            this.args = this._consumeUntil(function (next) { return _this._isFlag(next); });
            (_a = this.flags).push.apply(_a, this.argv);
        }
        else if (this._isNonEntityCommand(firstArg)) {
            this.command = firstArg;
            this.entity = this._getDefaultEntityForCommand(this.command);
            this.args = this._consumeUntil(function (next) { return _this._isFlag(next); });
            (_b = this.flags).push.apply(_b, this.argv);
        }
        else if (this._isAliasCommand(firstArg)) {
            _c = this._resolveAlias(firstArg), this.entity = _c[0], this.command = _c[1];
            this.args = this._consumeUntil(function (next) { return _this._isFlag(next); });
            (_d = this.flags).push.apply(_d, this.argv);
        }
        else if (this._isFlagOnlyCommand(firstArg)) {
            this.command = this._getDefaultCommandForFlag(firstArg);
            this.entity = this._getDefaultEntityForCommand(this.command);
            this.flags = this.argv.slice();
        }
        else if (firstArg === undefined) {
            this.command = 'help';
        }
        else {
            throw new Error("Invalid command: mdb " + processArgv.slice(2).join(' '));
        }
    };
    /**
     * If the `_validEntities` Set has this value, it's an entity.
     *
     * @param {string} arg
     * @returns {boolean}
     * @private
     */
    CommandInvoker.prototype._isEntity = function (arg) {
        return this._validEntities.has(arg);
    };
    /**
     * If the `_validNonEntityCommands` Set has this value, it's a non-entity command.
     *
     * @param {string} arg
     * @returns {boolean}
     * @private
     */
    CommandInvoker.prototype._isNonEntityCommand = function (arg) {
        return this._validNonEntityCommands.has(arg);
    };
    /**
     * If the `_validAliasCommands` Set has this value, it's an alias.
     *
     * @param {string | AliasCommand} arg
     * @returns {boolean}
     * @private
     */
    CommandInvoker.prototype._isAliasCommand = function (arg) {
        return this._validAliasCommands.has(arg);
    };
    /**
     * If it's a flag and the `_validFlagOnlyCommands` Set has this value, it's a flag-only command.
     *
     * @param arg
     * @returns {*|boolean}
     * @private
     */
    CommandInvoker.prototype._isFlagOnlyCommand = function (arg) {
        return this._isFlag(arg) && this._validFlagOnlyCommands.has(arg);
    };
    /**
     * If it starts with a `-` it's a flag.
     * Throws error if flag contain `=` instead of space.
     *
     * @param {string} arg
     * @returns {boolean}
     * @throws Error
     * @private
     */
    CommandInvoker.prototype._isFlag = function (arg) {
        var isFlag = !!arg && arg.startsWith('-');
        if (isFlag && arg.includes('='))
            throw new Error('Please use space instead of `=` on flags');
        return isFlag;
    };
    /**
     * Remove and return the first element of the current `argv` array.
     *
     * @returns {string}
     * @private
     */
    CommandInvoker.prototype._consumeNext = function () {
        return this.argv.shift();
    };
    /**
     * Return but don't remove the first element from the current `argv` array
     *
     * @returns {string}
     * @private
     */
    CommandInvoker.prototype._getNext = function () {
        return this.argv[0];
    };
    /**
     * A function that is applied to each element and if it returns `true` the element will be added to the returning collection.
     *
     * @typedef StopCondition
     * @function
     * @param {string} next
     * @return {boolean}
     */
    /**
     * Remove and return elements from the `argv` array until the `stopCondition` predicate function returns true or until there are still elements in the array.
     * As long as the `stopCondition` predicate returns `true`
     *
     * @param {StopCondition} stopCondition
     * @returns {string[]}
     * @private
     */
    CommandInvoker.prototype._consumeUntil = function (stopCondition) {
        var consumed = [];
        var next = this._getNext();
        while (!stopCondition(next) && next !== undefined) {
            consumed.push(this._consumeNext());
            next = this._getNext();
        }
        return consumed;
    };
    /**
     * A method that based on the selected command, imports the proper <code>Command</code> file and calls the <code>execute()</code> method on it.
     *
     * @async
     * @returns {Promise<void>}
     */
    CommandInvoker.prototype.executeCommand = function () {
        return __awaiter(this, void 0, void 0, function () {
            var ctx, CommandClass, command, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        ctx = new context_1.default(this.entity, this.command, this.args, this.flags);
                        CommandClass = require(path_1.default.resolve(__dirname, 'commands', this.command + "-command"));
                        command = new CommandClass(ctx);
                        return [4 /*yield*/, command.execute()];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1.message && e_1.message.toLowerCase().startsWith('cannot find module')) {
                            throw new Error("Invalid command: " + this.command);
                        }
                        else {
                            throw e_1;
                        }
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    CommandInvoker.prototype._getDefaultEntityForCommand = function (command) {
        switch (command) {
            case 'config':
                return 'config';
            case 'logs':
            case 'kill':
                return 'backend';
            case 'help':
            case 'update':
            case 'version':
                return 'app';
            case 'whoami':
            case 'register':
            case 'login':
            case 'logout':
            case 'status':
                return 'user';
            case 'delete':
            case 'get':
            case 'info':
            case 'init':
            case 'ls':
            case 'publish':
            case 'rename':
            case 'restart':
            case 'run':
                return '';
            default:
                throw new Error('Invalid command');
        }
    };
    CommandInvoker.prototype._getDefaultCommandForFlag = function (flag) {
        switch (flag) {
            case '-v':
            case '--version':
                return 'version';
            case '-h':
            case '--help':
                return 'help';
            default:
                throw new Error('Invalid command');
        }
    };
    CommandInvoker.prototype._resolveAlias = function (alias) {
        switch (alias) {
            case 'starters':
                return ['starter', 'ls'];
            case 'orders':
                return ['order', 'ls'];
        }
    };
    return CommandInvoker;
}());
exports.default = CommandInvoker;
